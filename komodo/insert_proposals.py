import argparse
import contextlib
import difflib
import os
from base64 import b64decode
from datetime import datetime
from typing import Dict, Mapping, MutableSet, Optional, Union

import github
from github import Github, UnknownObjectException
from github.GitRef import GitRef
from github.Repository import Repository

from komodo.prettier import write_to_string
from komodo.yaml_file_types import (
    KomodoException,
    ReleaseMatrixFile,
    RepositoryFile,
    UpgradeProposalsFile,
)


def recursive_update(
    to_be_upgraded: Mapping[str, Union[str, Mapping[str, str]]],
    upgrades: Optional[Mapping[str, Union[str, Mapping[str, str]]]],
) -> None:
    """Updates release in place with upgrades/additions of packages from upgrades.

    Takes format:
        package_name1: version_x

        package_name2:
                py38: version_y
                py312: version_z

        package_name3:
                py38:
                    rhel7: version_x
                    rhel8: version_y
    Args:
        to_be_upgraded (Mapping[str, Union[str, Mapping[str, str]]]):

        upgrades (Optional[Mapping[str, Union[str, Mapping[str, str]]]]):

    """
    if upgrades is None:
        return None
    for package_name, new_version_or_matrix in upgrades.items():
        old_version_or_matrix = to_be_upgraded.get(package_name)
        if isinstance(new_version_or_matrix, Mapping) and isinstance(
            old_version_or_matrix, Mapping
        ):
            recursive_update(old_version_or_matrix, new_version_or_matrix)
        else:
            to_be_upgraded[package_name] = new_version_or_matrix
    return to_be_upgraded


def _get_repo(token: str, fork: str, repo: str) -> Repository:
    client = Github(token)
    try:
        return client.get_repo(f"{fork}/{repo}")
    except UnknownObjectException:
        org = client.get_organization(fork)
        return org.get_repo(repo)


def diff_file_and_string(file_contents, string, leftname, rightname):
    return "".join(
        difflib.unified_diff(
            file_contents.splitlines(True),
            string.splitlines(True),
            leftname,
            rightname,
            n=0,
        ),
    )


def load_yaml_from_repo(filename, repo, ref) -> bytes:
    sym_conf_content = repo.get_contents(filename, ref=ref)
    return b64decode(sym_conf_content.content)


def main():
    args = parse_args()
    repo = _get_repo(os.getenv("GITHUB_TOKEN"), args.git_fork, args.git_repo)
    insert_proposals(
        repo,
        args.base,
        args.target,
        args.git_ref,
        args.jobname,
        args.joburl,
    )


def verify_branch_does_not_exist(repo: Repository, branch_name: str) -> None:
    try:
        repo.get_branch(branch_name)
    except github.GithubException:
        pass
    else:
        msg = f"Branch {branch_name} exists already"
        raise ValueError(msg)


def get_upgrade_key(target: str) -> str:
    year = target.split(".")[0]
    month = target.split(".")[1]
    return f"{year}-{month}"


def validate_upgrades(
    upgrade_section: Dict[str, str], repofile: RepositoryFile
) -> None:
    errors = set()
    for package_name, package_version in upgrade_section.items():
        recursive_validate_package_entries(
            package_name, package_version, repofile, errors
        )
    if errors:
        raise SystemExit("\n".join(errors))


def recursive_validate_package_entries(
    package_name,
    package_version_or_matrix: Union[str, Mapping],
    repository_file: RepositoryFile,
    errors: MutableSet,
) -> None:
    if isinstance(package_version_or_matrix, str):
        try:
            repository_file.validate_package_entry(
                package_name, package_version_or_matrix
            )
        except KomodoException as komodo_exception:
            errors.add(komodo_exception.error)
    else:
        for nested_version_or_matrix in package_version_or_matrix.values():
            recursive_validate_package_entries(
                package_name, nested_version_or_matrix, repository_file, errors
            )


def generate_contents_of_new_release_matrix(
    base_release_matrix_content: Mapping,
    repofile: RepositoryFile,
    upgrade: Optional[Dict],
) -> str:
    if upgrade:
        validate_upgrades(upgrade, repofile)
    recursive_update(base_release_matrix_content, upgrade)
    result = write_to_string(base_release_matrix_content)
    return result


PR_MSG_TEMPLATE = """:robot: Release {target}
---
### Description
- New Release: `{target}`
- Based on: `{base}`
- When: `{timestamp}`

### Diff
```diff
diff {base_file} {target_file}:
{diff}
```

### Details
_This pull request was generated by [{jobname}]({joburl})_.

Source code for this script can be found [here](https://github.com/equinor/komodo).
"""


def clean_proposals_file(
    proposal_file_content: Mapping[str, Mapping],
    upgrade_key: str,
    repo: Repository,
    git_ref: GitRef,
    tmp_target,
) -> None:
    proposal_file_content[upgrade_key] = None
    cleaned_upgrade = write_to_string(proposal_file_content, False)
    upgrade_contents = repo.get_contents("upgrade_proposals.yml", ref=git_ref)
    repo.update_file(
        "upgrade_proposals.yml",
        "Clean proposals",
        cleaned_upgrade,
        sha=upgrade_contents.sha,
        branch=tmp_target,
    )


def create_pr_with_changes(
    repo: Repository,
    git_ref: GitRef,
    target: str,
    from_sha: str,
    tmp_target: str,
    tmp_ref: GitRef,
    pr_msg: str,
):
    repo.create_git_ref(ref="refs/heads/" + target, sha=from_sha)
    # making a temporary PR in order to squash the commits into one
    tmp_pr = repo.create_pull(
        title=f"Temporary PR {target}",
        body="should not be seen",
        head=tmp_target,
        base=target,
    )
    tmp_pr.merge(
        commit_message=pr_msg,
        commit_title=f"Add release {target}",
        merge_method="squash",
    )
    with contextlib.suppress(github.GithubException):
        tmp_ref.delete()
        # If exception occurs, deletion is automatic

    # done with temporary PR, making the real PR:
    repo.create_pull(
        title=f"Add release {target}",
        body=pr_msg,
        head=target,
        base=git_ref,
    )


def create_new_release_file(
    repo: Repository, target: str, release_content: str, branch
) -> str:
    new_release_file = f"releases/matrices/{target}.yml"
    repo.create_file(
        new_release_file,
        f"Add release {target}",
        release_content,
        branch=branch,
    )
    return new_release_file


def insert_proposals(
    repo: Repository, base: str, target: str, git_ref: str, jobname: str, joburl: str
) -> None:
    tmp_target = target + ".tmp"

    verify_branch_does_not_exist(repo, target)
    verify_branch_does_not_exist(repo, tmp_target)

    upgrade_key = get_upgrade_key(target)

    proposals_yaml_string = load_yaml_from_repo("upgrade_proposals.yml", repo, git_ref)
    proposal_file = UpgradeProposalsFile().from_yaml_string(proposals_yaml_string)
    proposal_file.validate_upgrade_key(upgrade_key)

    base_file = f"releases/matrices/{base}.yml"
    release_file_yaml_string = load_yaml_from_repo(base_file, repo, git_ref)
    release_matrix_file = ReleaseMatrixFile.from_yaml_string(release_file_yaml_string)
    upgrade: Dict[str, str] = proposal_file.content.get(upgrade_key)

    repofile_yaml_string = load_yaml_from_repo("repository.yml", repo, git_ref)
    repofile = RepositoryFile().from_yaml_string(repofile_yaml_string)

    new_release_contents = generate_contents_of_new_release_matrix(
        release_matrix_file.content, repofile, upgrade
    )

    from_sha = repo.get_branch(git_ref).commit.sha
    tmp_ref = repo.create_git_ref(ref="refs/heads/" + tmp_target, sha=from_sha)
    new_release_file = create_new_release_file(
        repo, target, new_release_contents, tmp_target
    )

    clean_proposals_file(proposal_file.content, upgrade_key, repo, git_ref, tmp_target)

    base_content = repo.get_contents(base_file, ref=git_ref)
    diff = diff_file_and_string(
        b64decode(base_content.content).decode(),
        new_release_contents,
        base,
        target,
    )
    pr_msg = PR_MSG_TEMPLATE.format(
        target=target,
        base=base,
        timestamp=datetime.now(),
        base_file=base_file,
        target_file=new_release_file,
        diff=diff,
        jobname=jobname,
        joburl=joburl,
    )
    create_pr_with_changes(repo, git_ref, target, from_sha, tmp_target, tmp_ref, pr_msg)


class InsertProposalsNamespace(argparse.Namespace):
    """
    Komodo Insert Proposals argument parser namespace
    """

    base: str
    target: str
    joburl: str
    jobname: str
    git_fork: str
    git_repo: str
    git_ref: str


def parse_args() -> InsertProposalsNamespace:
    parser = argparse.ArgumentParser(
        description="Copy proposals into release and create PR.",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )
    parser.add_argument(
        "base",
        type=str,
        help=(
            "The name of the release matrix file to base on. (E.g. 2021.06.b0). "
            "A corresponding file must exist in releases/matrices"
        ),
    )
    parser.add_argument(
        "target",
        type=str,
        help="The name of the new release matrix file to create. (E.g. 2021.06.b0).",
    )
    parser.add_argument("joburl", help="link to the job that triggered this")
    parser.add_argument("jobname", help="name of the job")
    parser.add_argument("--git-fork", help="git fork", default="equinor")
    parser.add_argument("--git-repo", help="git repo", default="komodo-releases")
    parser.add_argument("--git-ref", help="git ref", default="main")
    return parser.parse_args(namespace=InsertProposalsNamespace())


if __name__ == "__main__":
    main()
